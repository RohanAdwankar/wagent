<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wagent</title>
  <style>
    :root{--bg:#0f0f10;--panel:#151516;--panel2:#1c1c1d;--text:#e9e9ea;--muted:#a5a5a8;--line:#2e2e31}
    *{box-sizing:border-box} body{margin:0;height:100vh;overflow:hidden;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;color:var(--text);background:var(--bg)}
    #app{display:grid;grid-template-columns:240px 1fr 380px;height:100vh;gap:1px;background:var(--line)}
    .panel,#editor-shell,#run-output-shell{min-height:0;display:flex;flex-direction:column}.panel{background:var(--panel)}
    .header,#editor-controls,#run-output-header,#chat-form{border-bottom:1px solid var(--line)}
    .header{padding:10px 12px;font-size:13px;color:var(--muted);display:flex;align-items:center;justify-content:space-between;gap:8px}.title{font-weight:600;color:var(--text)}
    button,input,textarea{font:inherit;color:var(--text);background:var(--panel2);border:1px solid var(--line);border-radius:0}button{padding:7px 10px;cursor:pointer;white-space:nowrap}button:disabled{opacity:.6;cursor:not-allowed}input{width:100%;padding:8px 10px}
    #tree,#chat-messages,#run-output{overflow:auto}#tree{padding:8px}
    .node{display:block;padding:5px 8px;color:var(--text);text-decoration:none;cursor:pointer}.node:hover,.node.active{background:#212938}.indent-1{padding-left:18px}.indent-2{padding-left:30px}.indent-3{padding-left:42px}.indent-4{padding-left:54px}
    #editor{width:100%;min-height:0;flex:1}#editor-controls{padding:8px 10px;display:grid;grid-template-columns:1fr auto auto auto;gap:8px;align-items:center}
    #editor-path,#status,#run-output-header{font-size:12px;color:var(--muted)}#editor-path{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    #run-output-shell{border-top:1px solid var(--line);max-height:180px}#run-output{margin:0;padding:8px 10px;font-size:12px;line-height:1.35;white-space:pre-wrap;word-break:break-word;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:var(--panel2);color:var(--text)}
    #chat-messages{flex:1;padding:10px;display:flex;flex-direction:column;gap:10px}
    .msg{padding:9px 10px;border:1px solid var(--line);background:var(--panel2);white-space:pre-wrap;word-break:break-word}.msg.user{border-color:#2e3f69;background:#162038}.msg.tool{border-color:#3c345e;background:#211a36;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}.msg.reasoning{border-color:#4a4a2e;background:#232316;color:#d9d59a}
    #chat-form{border-top:1px solid var(--line);padding:10px;display:grid;grid-template-columns:1fr auto;gap:8px}#prompt{min-height:82px;max-height:180px;resize:vertical;padding:10px}#status{padding:0 10px 8px}
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.3/ace.js"></script>
</head>
<body>
  <div id="app">
    <section class="panel">
      <div class="header">
        <span class="title">Files</span>
        <button id="new-file">New</button>
      </div>
      <div id="tree"></div>
    </section>

    <section class="panel" id="editor-shell">
      <div id="editor-controls">
        <div id="editor-path">No file selected</div>
        <button id="run-file">Run</button>
        <button id="save-file" disabled>Save</button>
        <button id="delete-file" disabled>Delete</button>
      </div>
      <div id="editor"></div>
      <div id="run-output-shell">
        <div id="run-output-header"></div>
        <pre id="run-output"></pre>
      </div>
    </section>

    <section class="panel">
      <div class="header">
        <span class="title">wagent</span>
      </div>
      <div id="chat-messages"></div>
      <div id="status">Ready.</div>
      <form id="chat-form">
        <textarea id="prompt" placeholder="Ask agent to create/edit files or run python..."></textarea>
        <button id="send" type="submit" disabled>Send</button>
      </form>
    </section>
  </div>

  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";

    const MODEL = "Llama-3.2-1B-Instruct-q4f16_1-MLC";
    const MAX_STEPS = 1000;
    const JSON_MODE_MAX_REPAIR = 3;
    const JSON_MODE_STALL_LIMIT = 8;
    const REACT_COMPACT_TRIGGER_MESSAGES = 28;
    const REACT_COMPACT_KEEP_TAIL = 14;
    const REACT_COMPACT_KEEP_TAIL_FORCE = 10;
    const TOOL_CALL_NAMES = ["read_file", "write_file", "run_python", "complete"];
    const CONVERSATION_HISTORY_LIMIT = 24;
    const REACT_TOOL_CALL_SCHEMA = JSON.stringify({
      type: "object",
      additionalProperties: false,
      required: ["thought", "action"],
      properties: {
        thought: { type: "string" },
        action: {
          type: "object",
          additionalProperties: false,
          required: ["tool", "args"],
          properties: {
            tool: { type: "string", enum: TOOL_CALL_NAMES },
            args: {
              type: "object",
              additionalProperties: true,
              properties: {
                path: { type: "string" },
                content: { type: "string" },
                code: { type: "string" },
                command: { type: "string" },
                message: { type: "string" }
              }
            }
          }
        }
      }
    });

    const el = {
      tree: document.getElementById("tree"),
      newFile: document.getElementById("new-file"),
      runFile: document.getElementById("run-file"),
      saveFile: document.getElementById("save-file"),
      deleteFile: document.getElementById("delete-file"),
      editorPath: document.getElementById("editor-path"),
      runOutput: document.getElementById("run-output"),
      send: document.getElementById("send"),
      prompt: document.getElementById("prompt"),
      messages: document.getElementById("chat-messages"),
      status: document.getElementById("status"),
      form: document.getElementById("chat-form")
    };

    const editor = ace.edit("editor", { theme: "ace/theme/monokai", mode: "ace/mode/python", fontSize: "13px", tabSize: 2, useSoftTabs: true, showPrintMargin: false });

    let engine = null;
    let pyodide = null;
    let activePath = null;
    let busy = false;
    let runBusy = false;
    let loadedModel = null;
    const conversationHistory = [];

    function trace(label, data) {
      const ts = new Date().toISOString();
      if (typeof data === "undefined") {
        console.log(`[wagent ${ts}] ${label}`);
        return;
      }
      console.log(`[wagent ${ts}] ${label}`, data);
    }

    const files = new Map();

    function setStatus(text) { el.status.textContent = text; }
    function setBusy(state) {
      busy = state;
      el.send.disabled = state || !engine;
    }

    function pushConversationMessage(role, content) {
      if (role !== "user" && role !== "assistant") return;
      const text = String(content || "").trim();
      if (!text) return;
      conversationHistory.push({ role, content: text });
      if (conversationHistory.length > CONVERSATION_HISTORY_LIMIT) {
        conversationHistory.splice(0, conversationHistory.length - CONVERSATION_HISTORY_LIMIT);
      }
    }

    function getConversationHistoryForModel() {
      return conversationHistory.map((m) => ({ role: m.role, content: m.content }));
    }

    function normalizePath(path) {
      return String(path || "").trim().replace(/^\/+/, "").replace(/\\+/g, "/");
    }

    function addMessage(role, content) {
      const d = document.createElement("div");
      d.className = `msg ${role}`;
      d.textContent = content;
      el.messages.appendChild(d);
      el.messages.scrollTop = el.messages.scrollHeight;
    }

    function buildTree(paths) {
      const root = {};
      for (const full of paths) {
        const parts = full.split("/");
        let cur = root;
        parts.forEach((part, i) => {
          if (!cur[part]) cur[part] = { __children: {}, __file: false };
          if (i === parts.length - 1) cur[part].__file = true;
          cur = cur[part].__children;
        });
      }
      return root;
    }

    function renderTree() {
      const tree = buildTree([...files.keys()].sort());
      el.tree.innerHTML = "";

      function walk(node, prefix = "", depth = 0) {
        Object.keys(node).sort().forEach((name) => {
          const item = node[name];
          const path = prefix ? `${prefix}/${name}` : name;
          const row = document.createElement("a");
          row.className = `node indent-${Math.min(depth, 4)}` + (activePath === path ? " active" : "");
          row.textContent = item.__file ? name : `${name}/`;
          if (item.__file) {
            row.onclick = () => openFile(path);
          }
          el.tree.appendChild(row);
          walk(item.__children, path, depth + 1);
        });
      }
      walk(tree);
    }

    function openFile(path) {
      activePath = path;
      el.editorPath.textContent = path;
      editor.session.setMode("ace/mode/python");
      editor.setValue(files.get(path) ?? "", -1);
      el.saveFile.disabled = false;
      el.deleteFile.disabled = false;
      renderTree();
    }

    function listDir(path = "") {
      const prefix = normalizePath(path);
      const out = [];
      const seen = new Set();
      for (const p of files.keys()) {
        if (prefix && !(p === prefix || p.startsWith(prefix + "/"))) continue;
        const rem = prefix ? p.slice(prefix.length).replace(/^\//, "") : p;
        const first = rem.split("/")[0];
        if (!first) continue;
        const full = prefix ? `${prefix}/${first}` : first;
        if (seen.has(full)) continue;
        seen.add(full);
        const isDir = [...files.keys()].some((k) => k.startsWith(full + "/"));
        out.push({ name: first, path: full, type: isDir ? "dir" : "file" });
      }
      return out.sort((a, b) => a.path.localeCompare(b.path));
    }

    function workspaceSnapshot() {
      const entries = [...files.entries()]
        .sort((a, b) => a[0].localeCompare(b[0]))
        .map(([path, content]) => ({ path, content }));
      return JSON.stringify({ files: entries });
    }

    function workspaceFileListText() {
      const paths = [...files.keys()].sort((a, b) => a.localeCompare(b));
      if (!paths.length) return "- (no files)";
      return paths.map((p) => `- ${p}`).join("\n");
    }

    function withWorkspaceFilesContext(text) {
      return `${String(text || "").trim()}\n\nWorkspace files:\n${workspaceFileListText()}`;
    }

    function firstString(...vals) {
      for (const v of vals) {
        if (typeof v === "string" && v.trim()) return v;
      }
      return "";
    }

    function resolvePathArg(args = {}) {
      return normalizePath(firstString(args.path, args.file, args.file_path, args.input_file, args.filename));
    }

    function normalizeToolName(rawName, args = {}) {
      const name = String(rawName || "").trim();
      const allowed = new Set(["read_file", "write_file", "run_python", "complete"]);
      if (allowed.has(name)) return name;

      if (/create[_\s-]?file/i.test(name) && resolvePathArg(args)) return "write_file";

      const parts = name.split(/[|,/\s]+/).map((p) => p.trim()).filter(Boolean);
      const validParts = parts.filter((p) => allowed.has(p));
      if (validParts.length === 1) return validParts[0];
      if (validParts.length > 1) {
        if (typeof args?.message === "string") return "complete";
        if (typeof args?.content === "string") return "write_file";
        if (typeof args?.code === "string" || typeof args?.command === "string") return "run_python";
        const path = resolvePathArg(args);
        if (path.toLowerCase().endsWith(".py")) return "run_python";
        if (path) return "read_file";
        return validParts[0];
      }
      return name;
    }

    function sanitizeToolArgs(toolName, rawArgs = {}) {
      const args = rawArgs && typeof rawArgs === "object" ? rawArgs : {};
      const path = resolvePathArg(args);

      if (toolName === "read_file") {
        return { path };
      }
      if (toolName === "write_file") {
        return { path, content: String(firstString(args.content, args.code) || "") };
      }
      if (toolName === "run_python") {
        const command = firstString(args.command);
        const code = firstString(args.code, args.content);
        const out = {};
        if (path) out.path = path;
        if (code) out.code = code;
        if (command) out.command = command;
        return out;
      }
      if (toolName === "complete") {
        return { message: String(firstString(args.message, args.summary, args.final) || "Done.") };
      }
      return args;
    }

    function normalizeToolCallForWorkspace(toolName, toolArgs) {
      const args = sanitizeToolArgs(toolName, toolArgs);
      return { toolName, toolArgs: args, note: "" };
    }

    function summarizeRunResult(path, output) {
      let summary = `Ran ${path}.`;
      try {
        const parsed = JSON.parse(output);
        if (parsed?.ok) {
          const stdout = String(parsed.stdout || "").trim();
          const stderr = String(parsed.stderr || "").trim();
          if (stdout) summary = `Ran ${path}. Output:\n${stdout}`;
          else if (stderr) summary = `Ran ${path}. stderr:\n${stderr}`;
          else summary = `Ran ${path} successfully with no output.`;
        } else {
          const err = String(parsed?.error || "").trim();
          const stderr = String(parsed?.stderr || "").trim();
          if (err) summary = `Failed to run ${path}: ${err}`;
          else if (stderr) summary = `Failed to run ${path}. stderr:\n${stderr}`;
          else summary = `Failed to run ${path}.`;
        }
      } catch {}
      return summary;
    }

    function formatRunPythonToolDisplay(args, output) {
      const path = resolvePathArg(args);
      const command = firstString(args?.command);
      const runCmd = command || (path ? `python ${path}` : "python <code>");

      let lines = [];
      try {
        const parsed = JSON.parse(output);
        const stdout = String(parsed?.stdout || "");
        const stderr = String(parsed?.stderr || "");
        const err = String(parsed?.error || "");

        if (parsed?.ok === false) {
          lines.push(`> ERROR: ${err || stderr || "execution failed"}`);
        } else {
          const outLines = stdout.split("\n").filter((l) => l.length > 0);
          if (outLines.length) {
            lines.push(...outLines.map((line) => `> ${JSON.stringify(line)}`));
          }
          if (stderr.trim()) {
            lines.push(...stderr.split("\n").filter((l) => l.length > 0).map((line) => `> STDERR: ${JSON.stringify(line)}`));
          }
        }
      } catch {
        lines.push(`> ${output}`);
      }

      if (!lines.length) lines.push("> (no output)");
      return `% ${runCmd}\n${lines.join("\n")}`;
    }

    function formatToolDisplay(name, args, output) {
      if (name === "run_python") {
        return formatRunPythonToolDisplay(args || {}, output);
      }
      if (name === "write_file") {
        try {
          const parsed = JSON.parse(output);
          const path = String(parsed?.path || resolvePathArg(args || {}));
          if (parsed?.ok && path) return `Created ${path}`;
        } catch {}
        const path = resolvePathArg(args || {}) || "(unknown path)";
        return `write_file(${path})\n${output}`;
      }
      return `${name}(${JSON.stringify(args || {})})\n${output}`;
    }

    function setRunOutput(path, output) {
      const header = `% python ${path}`;
      try {
        const parsed = JSON.parse(output);
        if (parsed?.ok === false) {
          const msg = String(parsed?.error || parsed?.stderr || "execution failed").trim();
          el.runOutput.textContent = `${header}\n${msg || "execution failed"}`;
          return;
        }

        const stdout = String(parsed?.stdout || "");
        const stderr = String(parsed?.stderr || "");
        const lines = [header];
        if (stdout.trim()) lines.push(stdout.trimEnd());
        if (stderr.trim()) lines.push(`stderr:\n${stderr.trimEnd()}`);
        if (!stdout.trim() && !stderr.trim()) lines.push("(no output)");
        el.runOutput.textContent = lines.join("\n\n");
      } catch {
        el.runOutput.textContent = `${header}\n${String(output || "")}`;
      }
    }

    function detectRunTarget(userText) {
      const text = String(userText || "").trim();
      const hasMutationIntent = /\b(edit|write|create|modify|update|add|implement|refactor)\b/i.test(text);
      const explicit = text.match(/^\s*run\s+([^\s]+\.py)\s*$/i);
      if (explicit) return normalizePath(explicit[1]);

      const hasRunIntent = /\b(run|execute)\b/i.test(text);
      const refersToFile = /\b(file|script|python)\b/i.test(text);
      if (hasMutationIntent || !hasRunIntent || !refersToFile) return "";

      const pyFiles = [...files.keys()].filter((p) => p.toLowerCase().endsWith(".py"));
      if (pyFiles.length === 1) return pyFiles[0];
      return "";
    }

    function requestNeedsScriptCreation(userText) {
      const text = String(userText || "").trim();
      const asksCreate = /\b(write|create|make|generate|build)\b/i.test(text);
      const asksScript = /\b(python|script|file|program)\b/i.test(text);
      return asksCreate && asksScript;
    }


    function stripWrappingQuotes(value) {
      const s = String(value || "").trim();
      if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
        return s.slice(1, -1);
      }
      return s;
    }

    function splitTopLevelArgs(rawArgs) {
      const src = String(rawArgs || "").trim();
      if (!src) return [];
      const out = [];
      let cur = "";
      let depth = 0;
      let inString = false;
      let quote = "";
      let escaped = false;

      for (let i = 0; i < src.length; i++) {
        const ch = src[i];
        if (inString) {
          cur += ch;
          if (escaped) {
            escaped = false;
            continue;
          }
          if (ch === "\\") {
            escaped = true;
            continue;
          }
          if (ch === quote) {
            inString = false;
            quote = "";
          }
          continue;
        }

        if (ch === '"' || ch === "'") {
          inString = true;
          quote = ch;
          cur += ch;
          continue;
        }

        if (ch === "(" || ch === "[" || ch === "{") {
          depth += 1;
          cur += ch;
          continue;
        }
        if (ch === ")" || ch === "]" || ch === "}") {
          if (depth > 0) depth -= 1;
          cur += ch;
          continue;
        }

        if (ch === "," && depth === 0) {
          out.push(cur.trim());
          cur = "";
          continue;
        }

        cur += ch;
      }

      if (cur.trim()) out.push(cur.trim());
      return out;
    }

    function mapSimpleToolName(rawName) {
      const n = String(rawName || "").trim().toLowerCase();
      if (n === "read_file" || n === "read") return "read_file";
      if (n === "create_file" || n === "create") return "write_file";
      if (n === "write_file" || n === "write") return "write_file";
      if (n === "run_python" || n === "run") return "run_python";
      if (n === "complete" || n === "done") return "complete";
      return "";
    }

    function parseSimpleToolCallLine(line, impliedPath = "main.py") {
      let candidate = String(line || "").trim();
      if (!candidate) return null;

      candidate = candidate.replace(/^NEXT_TOOL_(?:CALL|JSON)\s*:\s*/i, "").trim();
      candidate = candidate.replace(/^FOLLOWED\s+BY\s*:\s*/i, "").trim();
      candidate = candidate.replace(/^CALL\s*:\s*/i, "").trim();

      const match = candidate.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*\((.*)\)\s*$/);
      if (!match) return null;

      const mappedTool = mapSimpleToolName(match[1]);
      if (!mappedTool) return null;

      const argsList = splitTopLevelArgs(match[2] || "");
      const defaultPath = normalizePath(impliedPath || activePath || "main.py") || "main.py";
      const first = stripWrappingQuotes(argsList[0] || "");
      const restJoined = stripWrappingQuotes(argsList.slice(1).join(",").trim());

      if (mappedTool === "read_file") {
        return { tool: "read_file", args: { path: normalizePath(first || defaultPath) } };
      }
      if (mappedTool === "write_file") {
        if (!argsList.length) return null;
        if (argsList.length === 1) {
          return { tool: "write_file", args: { path: defaultPath, content: stripWrappingQuotes(argsList[0]) } };
        }
        return { tool: "write_file", args: { path: normalizePath(first), content: restJoined } };
      }
      if (mappedTool === "run_python") {
        if (!argsList.length) return { tool: "run_python", args: { path: defaultPath } };
        const val = stripWrappingQuotes(argsList.join(",").trim());
        if (/^python(?:3)?\s+/i.test(val)) return { tool: "run_python", args: { command: val } };
        if (/\.py$/i.test(val)) return { tool: "run_python", args: { path: normalizePath(val) } };
        return { tool: "run_python", args: { code: val } };
      }
      if (mappedTool === "complete") {
        return { tool: "complete", args: { message: stripWrappingQuotes(argsList.join(",").trim()) || "Done." } };
      }

      return null;
    }

    function parseSimpleToolCall(text, impliedPath = "main.py") {
      const source = String(text || "").trim();
      if (!source) return null;

      const fence = source.match(/```(?:json|text)?\s*([\s\S]*?)```/i);
      const raw = (fence ? fence[1] : source).trim();
      const lines = raw.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
      for (let i = lines.length - 1; i >= 0; i--) {
        const parsed = parseSimpleToolCallLine(lines[i], impliedPath);
        if (parsed) return parsed;
      }
      const parsedRaw = parseSimpleToolCallLine(raw, impliedPath);
      if (parsedRaw) return parsedRaw;
      return null;
    }

    function parseToolCallResponse(text, impliedPath = "main.py") {
      const asJson = extractJsonObject(text);
      if (asJson && typeof asJson === "object" && asJson.tool) return asJson;
      return parseSimpleToolCall(text, impliedPath);
    }

    function extractCodeBlock(text) {
      const src = String(text || "");
      const pyFence = src.match(/```python\s*([\s\S]*?)```/i);
      if (pyFence && pyFence[1]) return String(pyFence[1]).trim();
      const anyFence = src.match(/```\s*([\s\S]*?)```/i);
      if (anyFence && anyFence[1]) return String(anyFence[1]).trim();

      const pyFenceOpenOnly = src.match(/```python\s*([\s\S]*)$/i);
      if (pyFenceOpenOnly && pyFenceOpenOnly[1]) return String(pyFenceOpenOnly[1]).trim();
      const anyFenceOpenOnly = src.match(/```\s*([\s\S]*)$/i);
      if (anyFenceOpenOnly && anyFenceOpenOnly[1]) return String(anyFenceOpenOnly[1]).trim();

      const lines = src.split(/\r?\n/);
      const codeish = lines.filter((line) => {
        const l = String(line || "");
        return /^\s*(def\s+|class\s+|import\s+|from\s+|if\s+__name__\s*==\s*["']__main__["']\s*:|for\s+|while\s+|return\s+|print\(|[A-Za-z_][A-Za-z0-9_]*\s*=)/.test(l)
          || /^\s*$/.test(l);
      });
      if (codeish.length >= 3) {
        const candidate = codeish.join("\n").trim();
        if (candidate) return candidate;
      }
      return "";
    }

    function extractLikelyPythonPath(text, fallback = "main.py") {
      const m = String(text || "").match(/\b([\w./-]+\.py)\b/i);
      if (m && m[1]) return normalizePath(m[1]);
      return normalizePath(fallback || "main.py") || "main.py";
    }

    function compactReactMessagesInPlace(messages, force = false) {
      if (!Array.isArray(messages) || messages.length <= 2) return false;
      if (!force && messages.length < REACT_COMPACT_TRIGGER_MESSAGES) return false;

      const head = messages.slice(0, 2);
      const keepTail = force ? REACT_COMPACT_KEEP_TAIL_FORCE : REACT_COMPACT_KEEP_TAIL;
      const tailStart = Math.max(2, messages.length - keepTail);
      const tail = messages.slice(tailStart);
      messages.length = 0;
      messages.push(...head, ...tail);
      return true;
    }

    function workspaceDigest() {
      return JSON.stringify([...files.entries()].sort((a, b) => a[0].localeCompare(b[0])));
    }

    function extractAnswerFromReact(text) {
      const src = String(text || "");
      const lines = src.split(/\r?\n/);
      for (const line of lines) {
        const m = line.match(/^Answer:\s*(.*)$/i);
        if (m) return String(m[1] || "").trim();
      }
      return "";
    }

    function parseStructuredToolStep(text) {
      const parsed = extractJsonObject(text);
      if (!parsed || typeof parsed !== "object") return null;

      const thought = typeof parsed.thought === "string" ? parsed.thought.trim() : "";
      const action = parsed.action && typeof parsed.action === "object" ? parsed.action : null;
      if (!thought || !action) return null;

      const tool = String(action.tool || "").trim();
      if (!TOOL_CALL_NAMES.includes(tool)) return null;

      const args = action.args && typeof action.args === "object" && !Array.isArray(action.args)
        ? action.args
        : {};

      return { thought, action: { tool, args } };
    }


    function ensurePyodideDir(py, dirPath) {
      const parts = String(dirPath || "").split("/").filter(Boolean);
      let cur = "";
      for (const part of parts) {
        cur += `/${part}`;
        try {
          py.FS.mkdir(cur);
        } catch {}
      }
    }

    function syncWorkspaceToPyodide(py) {
      for (const [pathRaw, content] of files.entries()) {
        const path = normalizePath(pathRaw);
        const dir = path.split("/").slice(0, -1).join("/");
        if (dir) ensurePyodideDir(py, dir);
        py.FS.writeFile(`/${path}`, String(content ?? ""), { encoding: "utf8" });
      }
    }

    async function ensurePyodide() {
      if (pyodide) return pyodide;
      trace("ensurePyodide:start");
      setStatus("Loading Pyodide...");
      if (!window.loadPyodide) {
        await new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = "https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js";
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }
      pyodide = await window.loadPyodide();
      trace("ensurePyodide:ready", { version: pyodide?.version || "unknown" });
      setStatus("Pyodide ready.");
      return pyodide;
    }

    async function runTool(name, args) {
      trace("tool:call", { name, args });
      try {
        if (name === "read_file") {
          const path = resolvePathArg(args);
          if (!files.has(path)) {
            const result = JSON.stringify({ ok: false, error: "File not found" });
            trace("tool:result", { name, result });
            return result;
          }
          const result = JSON.stringify({ ok: true, path, content: files.get(path) });
          trace("tool:result", { name, result });
          return result;
        }
        if (name === "write_file") {
          const path = normalizePath(resolvePathArg(args));
          if (!path) {
            const result = JSON.stringify({ ok: false, error: "Invalid path" });
            trace("tool:result", { name, result });
            return result;
          }
          files.set(path, String(args.content ?? ""));
          openFile(path);
          const result = JSON.stringify({ ok: true, path, bytes: files.get(path).length });
          trace("tool:result", { name, result });
          return result;
        }
        if (name === "run_python") {
          const py = await ensurePyodide();
          syncWorkspaceToPyodide(py);
          let code = String(args.code ?? "");
          let runPath = "";
          const directPath = resolvePathArg(args);
          if (directPath && files.has(directPath)) {
            runPath = directPath;
          }
          if (!code.trim()) {
            if (runPath) {
              code = String(files.get(runPath) ?? "");
            }
          }
          if (!code.trim()) {
            const command = String(args.command ?? "").trim();
            const cmdMatch = command.match(/^python(?:3)?\s+(.+)$/i);
            if (cmdMatch) {
              const path = normalizePath(cmdMatch[1]);
              if (files.has(path)) {
                runPath = path;
                code = String(files.get(path) ?? "");
              }
            }
          }
          if (!code.trim()) {
            const result = JSON.stringify({ ok: false, error: "run_python requires code, path, or python command" });
            trace("tool:result", { name, result });
            return result;
          }
          trace("tool:run_python:code", code);
          py.globals.set("__code", code);
          py.globals.set("__run_path", runPath ? `/${runPath}` : "");
          const result = await py.runPythonAsync(`
      import textwrap
      _runner = textwrap.dedent("""
      import io, sys, traceback, runpy
      import builtins
      _out = io.StringIO()
      _err = io.StringIO()
      _old_out, _old_err = sys.stdout, sys.stderr
      _old_input = builtins.input
      sys.stdout, sys.stderr = _out, _err
      val = None
      ok = True
      try:
        builtins.input = lambda prompt='': (print(prompt, end='') or '')
        if '/' not in sys.path:
          sys.path.insert(0, '/')
        if __run_path:
          ns = runpy.run_path(__run_path, run_name='__main__')
          val = ns.get('_', None) if isinstance(ns, dict) else None
        else:
          ns = {}
          exec(__code, ns)
          val = ns.get('_', None)
      except Exception:
        ok = False
        traceback.print_exc()
      finally:
        builtins.input = _old_input
        sys.stdout, sys.stderr = _old_out, _old_err
      __wagent_payload = {'ok': ok, 'stdout': _out.getvalue(), 'stderr': _err.getvalue(), 'result': repr(val)}
      """)
      exec(_runner)
      __wagent_payload
          `);
          const payload = JSON.stringify(result.toJs ? result.toJs() : result);
          trace("tool:result", { name, result: payload });
          return payload;
        }
        if (name === "complete") {
          const message = firstString(args.message, args.summary, args.final) || "Done.";
          const result = JSON.stringify({ ok: true, done: true, message });
          trace("tool:result", { name, result });
          return result;
        }
        const result = JSON.stringify({ ok: false, error: `Unknown tool ${name}` });
        trace("tool:result", { name, result });
        return result;
      } catch (err) {
        const result = JSON.stringify({ ok: false, error: String(err?.message || err) });
        trace("tool:error", { name, args, error: err, result });
        return result;
      }
    }

    async function runAgent(userText) {
      trace("agent:start", { userText, model: loadedModel, mode: "react-tool-mode" });
      const priorHistory = getConversationHistoryForModel();
      pushConversationMessage("user", userText);

      const runTarget = detectRunTarget(userText);
      if (runTarget) {
        const path = runTarget;
        trace("agent:quick-run", { path });
        const output = await runTool("run_python", { path });
        addMessage("tool", formatToolDisplay("run_python", { path }, output));
        const summary = summarizeRunResult(path, output);
        addMessage("assistant", summary);
        pushConversationMessage("assistant", summary);
        setStatus("Done.");
        return;
      }

      trace("agent:dispatch", "Using ReAct tool mode");
      return runAgentReactToolMode(userText, priorHistory);
    }

    function extractJsonObject(text) {
      const source = String(text || "").trim();
      const fence = source.match(/```(?:json)?\s*([\s\S]*?)```/i);
      const raw = (fence ? fence[1] : source).trim();
      try {
        return JSON.parse(raw);
      } catch {
        const start = raw.indexOf("{");
        const end = raw.lastIndexOf("}");
        if (start >= 0 && end > start) {
          try { return JSON.parse(raw.slice(start, end + 1)); } catch {}
        }
      }
      const candidates = [];
      let depth = 0;
      let start = -1;
      let inString = false;
      let escaped = false;
      for (let i = 0; i < raw.length; i++) {
        const ch = raw[i];
        if (inString) {
          if (escaped) escaped = false;
          else if (ch === "\\") escaped = true;
          else if (ch === '"') inString = false;
          continue;
        }
        if (ch === '"') {
          inString = true;
          continue;
        }
        if (ch === "{") {
          if (depth === 0) start = i;
          depth += 1;
        } else if (ch === "}") {
          if (depth > 0) depth -= 1;
          if (depth === 0 && start >= 0) {
            candidates.push(raw.slice(start, i + 1));
            start = -1;
          }
        }
      }
      for (const cand of candidates) {
        try {
          const parsed = JSON.parse(cand);
          if (parsed && typeof parsed === "object") return parsed;
        } catch {}
      }
      return null;
    }

    async function runAgentReactToolMode(userText, priorHistory = []) {
      trace("agent-react:start", { userText, model: loadedModel });
      const snapshot = workspaceSnapshot();
      const userTurnWithFiles = withWorkspaceFilesContext(userText);
      const messages = [
        {
          role: "system",
          content:
            `You are wagent, a coding agent that MUST output one JSON object per step.
Your output is schema-constrained and must include:
- thought: short reasoning about the latest observation
- action: { tool, args }

Tool names (exact, lowercase): ${TOOL_CALL_NAMES.join(", ")}.

Behavior requirements:
- Continue tool-use loop until task is complete, then call tool "complete" with args.message.
- If the user asks a general question that does not require file/tool operations, call "complete" immediately with the answer.
- For coding requests, use write_file/read_file as needed.
- If the workspace has no files and the user asks to write code, create a new file with write_file (for Python use main.py unless user specifies another path).
- If you write a Python file (.py), run it with run_python before completing when execution is relevant.
- For requests like "write/create a python script", follow this exact order:
  1) write_file(path, non-empty python content)
  2) run_python(path)
  3) complete(message with result)
- Do not call complete before step 2 for script-creation requests.
- Do not write empty file content for script-creation requests.
- After writing a script, prefer run_python over additional write_file/read_file loops unless fixing an execution error.
- Prefer non-interactive scripts unless user requests interactivity.
- Prefer minimal steps; do not rewrite files repeatedly after successful output already satisfies request.
- Keep thought concise.

You receive current workspace files in every user/observation message, so do not call any file-listing tool.
Never refuse with "no workspace files" or similar when the user asks to create/write code; create the file instead.

Example (schema-shaped intent):
- thought: "Need to create script first"
  action: {"tool":"write_file","args":{"path":"main.py","content":"print(234*243 > 34234234)\n"}}
- thought: "Now run the script"
  action: {"tool":"run_python","args":{"path":"main.py"}}
- thought: "Output confirms result"
  action: {"tool":"complete","args":{"message":"Created and ran main.py. Result was False."}}

Current workspace snapshot (authoritative): ${snapshot}`
        },
  ...priorHistory,
  { role: "user", content: userTurnWithFiles }
      ];
      let structuredErrorCount = 0;
      let blockedInvalidCompleteCount = 0;
      let repeatedToolCallCount = 0;
      let previousToolFingerprint = "";
      let consecutiveNoProgress = 0;
      let impliedPath = activePath || "main.py";
      const requestLikelyNeedsWork = /\b(run|execute|read|write|edit|create|modify|update|add|implement|file|python|script|code)\b/i.test(userText);
      const requestLikelyNeedsRun = /\b(run|execute|test)\b/i.test(userText);
      const requestNeedsCreateScript = requestNeedsScriptCreation(userText);
      let successfulNonCompleteTools = 0;
      let successfulRunTools = 0;
      let successfulWriteTools = 0;
      let wrotePythonFile = false;
      let lastWrittenPythonPath = "";
      let lastRunPath = "";
      let lastRunOutput = "";

      for (let step = 0; step < MAX_STEPS; step++) {
        if (structuredErrorCount >= JSON_MODE_MAX_REPAIR || blockedInvalidCompleteCount >= 4) {
          const compacted = compactReactMessagesInPlace(messages, false);
          if (compacted) {
            trace("agent-react:messages-compacted", { step: step + 1, structuredErrorCount, blockedInvalidCompleteCount, size: messages.length, force: false });
          }
        }

        setStatus(`Thinking (${loadedModel || "model"}) step ${step + 1}/${MAX_STEPS}`);
        trace("agent-react:step:request", {
          step: step + 1,
          maxSteps: MAX_STEPS,
          messages
        });
        let completion;
        try {
          completion = await engine.chat.completions.create({
            messages,
            temperature: 0.2,
            max_tokens: 512,
            response_format: { type: "json_object", schema: REACT_TOOL_CALL_SCHEMA },
          });
        } catch (err) {
          const msg = String(err?.message || err || "");
          const isCtx = /ContextWindowSizeExceededError|context window size|Prompt tokens exceed context window/i.test(msg);
          if (isCtx) {
            const compacted = compactReactMessagesInPlace(messages, true);
            trace("agent-react:context-window-recovery", { step: step + 1, compacted, size: messages.length, error: msg });
            messages.push({
              role: "user",
              content: withWorkspaceFilesContext("Observation: History was compacted due context size. Continue from latest state and keep returning schema-valid JSON.")
            });
            continue;
          }
          throw err;
        }
        trace("agent-react:step:response", { step: step + 1, completion });

        const text = completion.choices?.[0]?.message?.content || "";
        const structuredStep = parseStructuredToolStep(text);
        if (!structuredStep) {
          structuredErrorCount += 1;
          trace("agent-react:malformed-structured-output", { step: step + 1, text, structuredErrorCount });
          messages.push({ role: "assistant", content: text || "" });
          messages.push({
            role: "user",
            content: withWorkspaceFilesContext(`Observation: Output was not valid against the required JSON schema. Return one JSON object with thought and action(tool,args). Retry ${structuredErrorCount}.`)
          });

          if (structuredErrorCount >= JSON_MODE_MAX_REPAIR * 3) {
            addMessage("assistant", "I stopped after repeated invalid structured outputs.");
            pushConversationMessage("assistant", "I stopped after repeated invalid structured outputs.");
            setStatus("Structured output stalled.");
            trace("agent-react:structured-stop", { step: step + 1, structuredErrorCount });
            return;
          }
          continue;
        }
        structuredErrorCount = 0;

        const thought = structuredStep.thought;
        addMessage("reasoning", thought);
        const parsed = {
          tool: structuredStep.action.tool,
          args: structuredStep.action.args
        };

        const toolNameRaw = String(parsed.tool || "").toLowerCase();
        const toolArgsRaw = parsed.args && typeof parsed.args === "object" ? parsed.args : {};
        const normalizedToolName = normalizeToolName(toolNameRaw, toolArgsRaw);
        const normalized = normalizeToolCallForWorkspace(normalizedToolName, toolArgsRaw);
        const toolName = normalized.toolName;
        const toolArgs = normalized.toolArgs;

        if (toolName === "read_file") {
          const readPath = resolvePathArg(toolArgs);
          const emptyWorkspace = files.size === 0;
          if (!readPath || (emptyWorkspace && requestLikelyNeedsWork && !files.has(readPath))) {
            structuredErrorCount += 1;
            const correction = !readPath
              ? `Observation: Invalid read_file call. args.path is required. If user asked for coding work, use write_file to create a file first.`
              : `Observation: Workspace is empty and ${readPath} does not exist. For coding requests, create a file first with write_file (for python prefer main.py), then continue.`;
            trace("agent-react:blocked-invalid-read-file", { step: step + 1, readPath, emptyWorkspace, structuredErrorCount });
            messages.push({ role: "assistant", content: JSON.stringify(structuredStep) });
            messages.push({ role: "user", content: withWorkspaceFilesContext(correction) });
            continue;
          }
        }

        if (toolName === "run_python") {
          const hasPath = !!resolvePathArg(toolArgs);
          const hasCode = typeof toolArgs.code === "string" && toolArgs.code.trim().length > 0;
          const hasCommand = typeof toolArgs.command === "string" && toolArgs.command.trim().length > 0;
          if (!hasPath && !hasCode && !hasCommand) {
            structuredErrorCount += 1;
            const correction = "Observation: Invalid run_python call. It requires args.path, args.code, or args.command. For script requests, use write_file to create main.py first, then run_python with that path.";
            trace("agent-react:blocked-invalid-run-python", { step: step + 1, structuredErrorCount });
            messages.push({ role: "assistant", content: JSON.stringify(structuredStep) });
            messages.push({ role: "user", content: withWorkspaceFilesContext(correction) });
            continue;
          }
        }

        if (toolName === "write_file" && requestNeedsCreateScript) {
          const writePath = resolvePathArg(toolArgs);
          const writeContent = String(toolArgs.content || "");
          if (!writePath || !writePath.toLowerCase().endsWith(".py") || !writeContent.trim()) {
            structuredErrorCount += 1;
            const correction = "Observation: Invalid write_file for script request. Use a .py path and non-empty Python content. Next action must be write_file with real script code.";
            trace("agent-react:blocked-invalid-write-file", { step: step + 1, writePath, bytes: writeContent.length, structuredErrorCount });
            messages.push({ role: "assistant", content: JSON.stringify(structuredStep) });
            messages.push({ role: "user", content: withWorkspaceFilesContext(correction) });
            continue;
          }
        }

        if (toolName === "complete") {
          const proposedMessage = String(firstString(toolArgs.message, toolArgs.summary, toolArgs.final) || "").trim();
          const looksLikeFormatError = /invalid format|please try again|retry|malformed|error/i.test(proposedMessage);
          const looksLikeWorkspaceRefusal = /no\s+workspace\s+files|workspace\s+is\s+empty|files\s+provided/i.test(proposedMessage);
          const missingRequiredWrite = requestNeedsCreateScript && successfulWriteTools === 0;
          const missingRequiredRun = requestLikelyNeedsWork && wrotePythonFile && successfulRunTools === 0;
          if (looksLikeFormatError || (requestLikelyNeedsWork && looksLikeWorkspaceRefusal) || missingRequiredWrite || missingRequiredRun) {
            structuredErrorCount += 1;
            blockedInvalidCompleteCount += 1;
            const reason = looksLikeFormatError
              ? "COMPLETE message is a format/retry error, not a task result"
              : ((requestLikelyNeedsWork && looksLikeWorkspaceRefusal)
                  ? "COMPLETE message refused due missing files, but user asked for coding work"
                  : (missingRequiredWrite
                      ? "COMPLETE called before creating requested script/file"
                      : "COMPLETE called before running written Python file"));
            const nextStepHint = missingRequiredWrite
              ? " Next action must be write_file for a .py file with non-empty code."
              : (missingRequiredRun
                  ? " Next action must be run_python on the .py file you wrote; do not call complete yet."
                  : "");
            const correction = `Observation: Invalid completion (${reason}). Continue solving the request and return schema-valid JSON for the next action. Attempt ${structuredErrorCount}.${nextStepHint}`;
            trace("agent-react:blocked-invalid-complete", { step: step + 1, proposedMessage, structuredErrorCount, reason });

            if (blockedInvalidCompleteCount >= 6) {
              addMessage("assistant", "I stopped after repeated invalid completion loops.");
              pushConversationMessage("assistant", "I stopped after repeated invalid completion loops.");
              setStatus("Stalled without progress.");
              trace("agent-react:stalled-invalid-complete-loop", { step: step + 1, blockedInvalidCompleteCount });
              return;
            }

            messages.push({ role: "assistant", content: JSON.stringify(structuredStep) });
            messages.push({ role: "user", content: withWorkspaceFilesContext(correction) });
            continue;
          }
        }
        blockedInvalidCompleteCount = 0;

        const beforeDigest = workspaceDigest();
        trace("agent-react:tool-call", { step: step + 1, toolName, toolArgs });
        const output = await runTool(toolName, toolArgs);
        const afterDigest = workspaceDigest();

        let toolOk = true;
        let toolError = "";
        try {
          const outParsed = JSON.parse(output);
          toolOk = outParsed?.ok !== false;
          toolError = String(outParsed?.error || "");
        } catch {}

        if (toolOk) {
          const p = resolvePathArg(toolArgs);
          if (p && (toolName === "read_file" || toolName === "write_file" || toolName === "run_python")) {
            impliedPath = p;
          }
          if (toolName === "write_file" && p && p.toLowerCase().endsWith(".py")) {
            wrotePythonFile = true;
            lastWrittenPythonPath = p;
          }
          if (toolName === "write_file") {
            successfulWriteTools += 1;
          }
          if (toolName !== "complete") successfulNonCompleteTools += 1;
          if (toolName === "run_python") successfulRunTools += 1;
          if (toolName === "run_python") {
            lastRunPath = resolvePathArg(toolArgs) || impliedPath || lastRunPath;
            lastRunOutput = output;
          }
        }

        if (toolName !== "complete") {
          addMessage("tool", formatToolDisplay(toolName, toolArgs, output));
        }
        const observation = toolOk ? output : `ERROR: ${toolError || output}`;
          messages.push({ role: "assistant", content: JSON.stringify(structuredStep) });
        messages.push({ role: "user", content: withWorkspaceFilesContext(`Observation: ${observation}`) });
          trace("agent-react:observation-appended", { step: step + 1, thought, toolName, toolOk, observation });

        const changedWorkspace = beforeDigest !== afterDigest;
        const wasProgress = toolOk && (changedWorkspace || toolName === "run_python");
        if (wasProgress) consecutiveNoProgress = 0;
        else consecutiveNoProgress += 1;

        const fingerprint = `${toolName}::${JSON.stringify(toolArgs)}::${output}`;
        if (fingerprint === previousToolFingerprint) repeatedToolCallCount += 1;
        else repeatedToolCallCount = 1;
        previousToolFingerprint = fingerprint;

        const shouldAutoRecoverRun =
          requestNeedsCreateScript &&
          wrotePythonFile &&
          successfulRunTools === 0 &&
          !!lastWrittenPythonPath &&
          blockedInvalidCompleteCount >= 3;
        if (shouldAutoRecoverRun) {
          const autoRunPath = lastWrittenPythonPath;
          const autoRunOutput = await runTool("run_python", { path: autoRunPath });
          addMessage("tool", formatToolDisplay("run_python", { path: autoRunPath }, autoRunOutput));
          let autoRunOk = true;
          try {
            const parsedAuto = JSON.parse(autoRunOutput);
            autoRunOk = parsedAuto?.ok !== false;
          } catch {}
          if (autoRunOk) {
            successfulRunTools += 1;
            const finalMessage = summarizeRunResult(autoRunPath, autoRunOutput);
            addMessage("assistant", finalMessage);
            pushConversationMessage("assistant", finalMessage);
            setStatus("Done.");
            trace("agent-react:auto-recover-run-complete", { step: step + 1, autoRunPath, finalMessage });
            return;
          }
          messages.push({ role: "assistant", content: JSON.stringify(structuredStep) });
          messages.push({
            role: "user",
            content: withWorkspaceFilesContext(`Observation: Auto-recovery run failed for ${autoRunPath}: ${autoRunOutput}. Continue with schema-valid next action.`)
          });
        }

        if (toolName === "complete") {
          let finalMessage = "Done.";
          try {
            const parsedOutput = JSON.parse(output);
            finalMessage = String(parsedOutput.message || toolArgs.message || "Done.");
          } catch {
            finalMessage = String(toolArgs.message || "Done.");
          }
          trace("agent-react:completed", { step: step + 1, finalMessage });
          addMessage("assistant", finalMessage);
          pushConversationMessage("assistant", finalMessage);
          setStatus("Done.");
          return;
        }

        if (repeatedToolCallCount >= 5 || consecutiveNoProgress >= JSON_MODE_STALL_LIMIT) {
          addMessage("assistant", "I stopped after getting stuck without progress.");
          pushConversationMessage("assistant", "I stopped after getting stuck without progress.");
          setStatus("Stalled without progress.");
          trace("agent-react:stalled-stop", { step: step + 1, repeatedToolCallCount, consecutiveNoProgress });
          return;
        }
      }
      trace("agent-react:stopped", { reason: "max-steps", maxSteps: MAX_STEPS });
      addMessage("assistant", "Stopped after max tool/reasoning steps.");
      pushConversationMessage("assistant", "Stopped after max tool/reasoning steps.");
      setStatus("Step limit reached.");
    }

    async function initEngine() {
      try {
        trace("engine:init:start", { model: MODEL });
        setBusy(true);
        setStatus(`Loading ${MODEL}...`);
        engine = await webllm.CreateMLCEngine(MODEL, {
          initProgressCallback: (p) => setStatus(p.text || "Loading...")
        });
        loadedModel = MODEL;
        trace("engine:init:ready", { model: MODEL });
        setStatus(`Model ready: ${MODEL}`);
        el.send.disabled = false;
      } catch (err) {
        trace("engine:init:error", err);
        setStatus(`Model load failed: ${err?.message || err}`);
      } finally {
        setBusy(false);
      }
    }

    el.newFile.onclick = () => {
      const path = normalizePath(prompt("New file path", "main.py") || "");
      if (!path) return;
      if (!files.has(path)) files.set(path, "");
      renderTree();
      openFile(path);
    };

    el.saveFile.onclick = () => {
      if (!activePath) return;
      files.set(activePath, editor.getValue());
      setStatus(`Saved ${activePath}`);
      renderTree();
    };

    el.runFile.onclick = async () => {
      if (!activePath || runBusy) return;
      if (!activePath.toLowerCase().endsWith(".py")) {
        setStatus("Run supports Python files (.py) only.");
        return;
      }

      files.set(activePath, editor.getValue());
      runBusy = true;
      setStatus(`Running ${activePath}...`);
      trace("ui:run-file", { path: activePath });
      try {
        const output = await runTool("run_python", { path: activePath });
        setRunOutput(activePath, output);
        setStatus(`Finished running ${activePath}.`);
      } catch (err) {
        trace("ui:run-file:error", err);
        el.runOutput.textContent = `Error: ${err?.message || err}`;
        setStatus("Run failed.");
      } finally {
        runBusy = false;
      }
    };

    el.deleteFile.onclick = () => {
      if (!activePath) return;
      if (!confirm(`Delete ${activePath}?`)) return;
      files.delete(activePath);
      activePath = null;
      editor.setValue("", -1);
      el.editorPath.textContent = "No file selected";
      el.saveFile.disabled = true;
      el.deleteFile.disabled = true;
      renderTree();
    };

    el.form.onsubmit = async (e) => {
      e.preventDefault();
      const text = el.prompt.value.trim();
      if (!text || !engine || busy) return;
      el.prompt.value = "";
      trace("ui:submit", { text });
      addMessage("user", text);
      setBusy(true);
      try {
        await runAgent(text);
      } catch (err) {
        trace("ui:submit:error", err);
        const errorMessage = `Error: ${err?.message || err}`;
        addMessage("assistant", errorMessage);
        pushConversationMessage("assistant", errorMessage);
        setStatus("Agent error.");
      } finally {
        setBusy(false);
      }
    };

    renderTree();
    editor.setValue("", -1);
    el.editorPath.textContent = "No file selected";
    el.saveFile.disabled = true;
    el.deleteFile.disabled = true;
    trace("app:init", { files: [...files.keys()] });
    trace("app:note", "Only model-visible output can be logged; hidden internal model reasoning is not exposed by WebLLM APIs.");
    initEngine();
  </script>
</body>
</html>
